{"version":3,"file":"find-now.js","sources":["../src/oceanUtils.ts","../src/find.ts","../src/find-now.ts"],"sourcesContent":["type OceanZone = {\n  left: number\n  right: number\n  tzid: string\n}\n\nexport const oceanZones: OceanZone[] = [\n  { tzid: 'Etc/GMT-12', left: 172.5, right: 180 },\n  { tzid: 'Etc/GMT-11', left: 157.5, right: 172.5 },\n  { tzid: 'Etc/GMT-10', left: 142.5, right: 157.5 },\n  { tzid: 'Etc/GMT-9', left: 127.5, right: 142.5 },\n  { tzid: 'Etc/GMT-8', left: 112.5, right: 127.5 },\n  { tzid: 'Etc/GMT-7', left: 97.5, right: 112.5 },\n  { tzid: 'Etc/GMT-6', left: 82.5, right: 97.5 },\n  { tzid: 'Etc/GMT-5', left: 67.5, right: 82.5 },\n  { tzid: 'Etc/GMT-4', left: 52.5, right: 67.5 },\n  { tzid: 'Etc/GMT-3', left: 37.5, right: 52.5 },\n  { tzid: 'Etc/GMT-2', left: 22.5, right: 37.5 },\n  { tzid: 'Etc/GMT-1', left: 7.5, right: 22.5 },\n  { tzid: 'Etc/GMT', left: -7.5, right: 7.5 },\n  { tzid: 'Etc/GMT+1', left: -22.5, right: -7.5 },\n  { tzid: 'Etc/GMT+2', left: -37.5, right: -22.5 },\n  { tzid: 'Etc/GMT+3', left: -52.5, right: -37.5 },\n  { tzid: 'Etc/GMT+4', left: -67.5, right: -52.5 },\n  { tzid: 'Etc/GMT+5', left: -82.5, right: -67.5 },\n  { tzid: 'Etc/GMT+6', left: -97.5, right: -82.5 },\n  { tzid: 'Etc/GMT+7', left: -112.5, right: -97.5 },\n  { tzid: 'Etc/GMT+8', left: -127.5, right: -112.5 },\n  { tzid: 'Etc/GMT+9', left: -142.5, right: -127.5 },\n  { tzid: 'Etc/GMT+10', left: -157.5, right: -142.5 },\n  { tzid: 'Etc/GMT+11', left: -172.5, right: -157.5 },\n  { tzid: 'Etc/GMT+12', left: -180, right: -172.5 },\n]\n\n/**\n * Find the Etc/GMT* timezone name(s) corresponding to the given longitue.\n *\n * @param lon The longitude to analyze\n * @returns An array of strings of TZIDs\n */\nexport function getTimezoneAtSea(lon: number): string[] {\n  // coordinates along the 180 longitude should return two zones\n  if (lon === -180 || lon === 180) {\n    return ['Etc/GMT+12', 'Etc/GMT-12']\n  }\n  const tzs = []\n  for (let i = 0; i < oceanZones.length; i++) {\n    const z = oceanZones[i]\n    if (z.left <= lon && z.right >= lon) {\n      tzs.push(z.tzid)\n    } else if (z.right < lon) {\n      break\n    }\n  }\n  return tzs\n}\n","import * as fs from 'fs'\n\nimport { decode } from 'geobuf'\nimport inside from '@turf/boolean-point-in-polygon'\nimport { point } from '@turf/helpers'\nimport Pbf from 'pbf'\n\nimport { getTimezoneAtSea, oceanZones } from './oceanUtils'\n\nexport type CacheOptions = {\n  /**\n   * If set to true, all features will be loaded into memory to shorten future lookup\n   * times.\n   */\n  preload?: boolean\n  /**\n   * Must be a map-like object with a `get` and `set` function.\n   */\n  store?: Map<string, any>\n}\n\n/**\n * Set caching behavior and return feature cache.\n *\n * @param tzData The index data of the timezeone data product\n * @param {string} featureFilePath The path to the binary geo.dat file for the timezeone data product\n * @param {CacheOptions} options cachine options.\n */\nexport function setCacheLevel(\n  tzData: any,\n  featureFilePath: string,\n  options?: CacheOptions,\n): Map<string, any> {\n  let featureCache\n  if (\n    options &&\n    options.store &&\n    typeof options.store.get === 'function' &&\n    typeof options.store.set === 'function'\n  ) {\n    featureCache = options.store\n  } else {\n    featureCache = new Map()\n  }\n  if (options && options.preload) {\n    const featureFileFd = fs.openSync(featureFilePath, 'r')\n\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n\n    _preCache(tzData, featureFilePath, featureFileFd, featureCache)\n\n    fs.closeSync(featureFileFd)\n  }\n  return featureCache\n}\n\n/**\n * A function that will load all features into an unexpiring cache\n *\n * @param tzData\n * @param {string} featureFilePath\n * @param {number} featureFileFd\n * @param featureCache\n * @returns {void}\n */\nfunction _preCache(\n  tzData: any,\n  featureFilePath: string,\n  featureFileFd: number,\n  featureCache: Map<string, any>,\n) {\n  // shoutout to github user @magwo for an initial version of this recursive function\n  function preloadFeaturesRecursive(curTzData, quadPos: string) {\n    if (curTzData.pos >= 0 && curTzData.len) {\n      const geoJson = loadFeatures(\n        featureFilePath,\n        curTzData.pos,\n        curTzData.len,\n        featureFileFd,\n      )\n      featureCache.set(quadPos, geoJson)\n    } else if (typeof curTzData === 'object') {\n      Object.getOwnPropertyNames(curTzData).forEach((value) => {\n        preloadFeaturesRecursive(curTzData[value], quadPos + value)\n      })\n    }\n  }\n  preloadFeaturesRecursive(tzData.lookup, '')\n}\n\n/**\n * Load features from geo.dat at offset pos with length len.\n * Optionally accept a file descriptor\n *\n * @param featureFilePath\n * @param pos\n * @param len\n * @param fd\n * @returns the GeoJSON features in within the given quad region as defined in the\n *  feature file data.\n */\nfunction loadFeatures(\n  featureFilePath: string,\n  pos: number,\n  len: number,\n  fd: number = -1,\n) {\n  let featureFileFd = fd\n  if (featureFileFd < 0) {\n    featureFileFd = fs.openSync(featureFilePath, 'r')\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n  }\n\n  // exact boundaries saved in file\n  // parse geojson for exact boundaries\n  const buf = Buffer.alloc(len)\n  const bytesRead = fs.readSync(featureFileFd, buf, 0, len, pos)\n\n  // close featureFileFd if we opened it\n  if (fd < 0) {\n    fs.closeSync(featureFileFd)\n  }\n\n  if (bytesRead < len) {\n    throw new Error(\n      `tried to read ${len} bytes from geo.dat but only got ${bytesRead} bytes`,\n    )\n  }\n\n  const data = new Pbf(buf)\n  return decode(data)\n}\n\n/**\n * Find the timezone ID(s) at the given GPS coordinates.\n *\n * @param tzData The indexed lookup dataset to use\n * @param featureCache The appropriate featureCache to use\n * @param featureFilePath The appropriate featureFilePath to use\n * @param lat latitude (must be >= -90 and <=90)\n * @param lon longitue (must be >= -180 and <=180)\n * @returns An array of string of TZIDs at the given coordinate.\n */\nexport function findUsingDataset(\n  tzData: any,\n  featureCache: any,\n  featureFilePath: string,\n  lat: number,\n  lon: number,\n): string[] {\n  const originalLon = lon\n\n  let err\n\n  // validate latitude\n  if (isNaN(lat) || lat > 90 || lat < -90) {\n    err = new Error('Invalid latitude: ' + lat)\n    throw err\n  }\n\n  // validate longitude\n  if (isNaN(lon) || lon > 180 || lon < -180) {\n    err = new Error('Invalid longitude: ' + lon)\n    throw err\n  }\n\n  // North Pole should return all ocean zones\n  if (lat === 90) {\n    return oceanZones.map((zone) => zone.tzid)\n  }\n\n  // fix edges of the world\n  if (lat >= 89.9999) {\n    lat = 89.9999\n  } else if (lat <= -89.9999) {\n    lat = -89.9999\n  }\n\n  if (lon >= 179.9999) {\n    lon = 179.9999\n  } else if (lon <= -179.9999) {\n    lon = -179.9999\n  }\n\n  const pt = point([lon, lat])\n  const quadData = {\n    top: 89.9999,\n    bottom: -89.9999,\n    left: -179.9999,\n    right: 179.9999,\n    midLat: 0,\n    midLon: 0,\n  }\n  let quadPos = ''\n  let curTzData = tzData.lookup\n\n  while (true) {\n    // calculate next quadtree position\n    let nextQuad\n    if (lat >= quadData.midLat && lon >= quadData.midLon) {\n      nextQuad = 'a'\n      quadData.bottom = quadData.midLat\n      quadData.left = quadData.midLon\n    } else if (lat >= quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'b'\n      quadData.bottom = quadData.midLat\n      quadData.right = quadData.midLon\n    } else if (lat < quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'c'\n      quadData.top = quadData.midLat\n      quadData.right = quadData.midLon\n    } else {\n      nextQuad = 'd'\n      quadData.top = quadData.midLat\n      quadData.left = quadData.midLon\n    }\n\n    // console.log(nextQuad)\n    curTzData = curTzData[nextQuad]\n    // console.log()\n    quadPos += nextQuad\n\n    // analyze result of current depth\n    if (!curTzData) {\n      // no timezone in this quad, therefore must be timezone at sea\n      return getTimezoneAtSea(originalLon)\n    } else if (curTzData.pos >= 0 && curTzData.len) {\n      // get exact boundaries\n      let geoJson = featureCache.get(quadPos)\n      if (!geoJson) {\n        geoJson = loadFeatures(featureFilePath, curTzData.pos, curTzData.len)\n        featureCache.set(quadPos, geoJson)\n      }\n\n      const timezonesContainingPoint = []\n\n      for (let i = 0; i < geoJson.features.length; i++) {\n        if (inside(pt, geoJson.features[i])) {\n          timezonesContainingPoint.push(geoJson.features[i].properties.tzid)\n        }\n      }\n\n      // if at least one timezone contained the point, return those timezones,\n      // otherwise must be timezone at sea\n      return timezonesContainingPoint.length > 0\n        ? timezonesContainingPoint\n        : getTimezoneAtSea(originalLon)\n    } else if (curTzData.length > 0) {\n      // exact match found\n      return curTzData.map((idx) => tzData.timezones[idx])\n    } else if (typeof curTzData !== 'object') {\n      // not another nested quad index, throw error\n      err = new Error('Unexpected data type')\n      throw err\n    }\n\n    // calculate next quadtree depth data\n    quadData.midLat = (quadData.top + quadData.bottom) / 2\n    quadData.midLon = (quadData.left + quadData.right) / 2\n  }\n}\n","import * as path from 'path'\n\nimport type { CacheOptions } from './find'\nimport { findUsingDataset, setCacheLevel } from './find'\n\nconst DATA_PATH =\n  process.env.GEO_TZ_DATA_PATH || path.join(__dirname, '..', 'data')\nconst TZ_DATA = require('../data/timezones-now.geojson.index.json')\nconst FEATURE_FILE_PATH = path.join(DATA_PATH, 'timezones-now.geojson.geo.dat')\nlet featureCache\n\n/**\n * Find the timezone ID(s) at the given GPS coordinates.\n *\n * This find method utilizes an abbreviated list of timezones provided in the timezone database.\n * Only those timezones that have distinct timekeeping methods since the latest release of the\n * timezone-boundary-builder project are included. Therefore, the use of this lookup method may\n * find an incorrect timekeeping method that does not properly account for variations in timekeeping\n * methods in the past.\n *\n * @param lat latitude (must be >= -90 and <=90)\n * @param lon longitue (must be >= -180 and <=180)\n * @returns An array of strings of TZIDs at the given coordinate.\n */\nexport function find(lat: number, lon: number): string[] {\n  return findUsingDataset(TZ_DATA, featureCache, FEATURE_FILE_PATH, lat, lon)\n}\n\n/**\n * Set caching behavior.\n *\n * @param {CacheOptions} options cachine options.\n */\nfunction cacheLevel(options?: CacheOptions) {\n  featureCache = setCacheLevel(TZ_DATA, FEATURE_FILE_PATH, options)\n}\n\ncacheLevel()\n\nexport { cacheLevel as setCache }\n\n/**\n * Load all features into memory to speed up future lookups.\n */\nexport function preCache() {\n  cacheLevel({ preload: true })\n}\n"],"names":["oceanZones","tzid","left","right","getTimezoneAtSea","lon","tzs","i","length","z","push","loadFeatures","featureFilePath","pos","len","fd","featureFileFd","fs","openSync","Error","buf","Buffer","alloc","bytesRead","readSync","closeSync","data","Pbf","decode","featureCache","DATA_PATH","process","env","GEO_TZ_DATA_PATH","path","join","__dirname","TZ_DATA","require","FEATURE_FILE_PATH","cacheLevel","options","tzData","store","get","set","Map","preload","preloadFeaturesRecursive","curTzData","quadPos","geoJson","Object","getOwnPropertyNames","forEach","value","lookup","_preCache","setCacheLevel","lat","originalLon","isNaN","map","zone","pt","point","quadData","top","bottom","midLat","midLon","nextQuad","timezonesContainingPoint","features","inside","properties","idx","timezones","findUsingDataset"],"mappings":"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"}